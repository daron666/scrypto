package scorex.crypto.hash

import org.scalatest.prop.{PropertyChecks, TableDrivenPropertyChecks}
import org.scalatest.{Matchers, PropSpec}
import ove.crypto.digest.Blake2b
import ove.crypto.digest.Blake2b.Digest
import scorex.utils.LittleEndianBytes.leIntToByteArray


class EquihashSpecification extends PropSpec
  with PropertyChecks
  with Matchers
  with TableDrivenPropertyChecks {

  val tasksAndSolutions =
    Table(
      ("n", "k", "I", "nonce", "solutions"), // First tuple defines column names
      (96, 5, "block header".getBytes, BigInt(0), Seq.empty[Seq[Int]]), // Subsequent tuples define the data
      (96, 5, "block header".getBytes, BigInt(1), Seq.empty[Seq[Int]]),
      (96, 5, "block header".getBytes, BigInt(2), Seq(Seq(3389, 110764, 37520, 58346, 4112, 61459, 47776, 84587, 11643, 34988, 36560, 98422, 36242, 47864, 76737, 80053, 3422, 74285, 77922, 101376, 58602, 104312, 64513, 89638, 10240, 76326, 27584, 36949, 43637, 75295, 56666, 91601))),
      (96, 5, "block header".getBytes, BigInt(10), Seq(
        Seq(787, 20674, 53516, 73404, 4022, 110690, 35427, 58606, 22749, 129878, 34185, 112292, 56949, 100033, 100182, 115894, 13225, 23627, 94405, 114446, 14243, 118738, 36358, 79934, 49517, 78196, 85137, 85376, 57430, 77040, 102235, 114826),
        Seq(2656, 33964, 2683, 87167, 19223, 113046, 67505, 101388, 12585, 77102, 18807, 117333, 70932, 106281, 85381, 118430, 6664, 12926, 6868, 33372, 15227, 128690, 89250, 96792, 14322, 23199, 32286, 57355, 54637, 130050, 70335, 99067),
        Seq(4207, 21880, 85981, 113070, 16301, 41187, 88537, 103201, 6295, 86241, 21605, 56786, 28030, 80680, 52120, 79774, 7875, 56055, 25882, 112870, 9719, 40271, 35223, 50883, 27959, 92599, 70158, 106739, 31838, 117463, 69735, 83367),
        Seq(9637, 51478, 44285, 93559, 76796, 108515, 123998, 124708, 17379, 29371, 21401, 48583, 62725, 80279, 109465, 111074, 16793, 128680, 42090, 42327, 34750, 101600, 64379, 84300, 48256, 49313, 82752, 87659, 67566, 117002, 78981, 122103),
      )),
      (96, 5, "block header".getBytes, BigInt(11), Seq(
        Seq(1638, 116919, 4749, 45156, 58749, 103900, 92294, 109359, 16076, 89395, 21938, 121398, 18847, 43685, 53116, 114427, 7067, 69901, 23179, 73689, 33890, 103453, 66168, 129978, 57522, 115912, 81791, 123826, 76090, 96629, 120289, 123662),
        Seq(2957, 38313, 18116, 83967, 10458, 51007, 13244, 61860, 16311, 113118, 76034, 90819, 43134, 61561, 68365, 93667, 7626, 86183, 62381, 109415, 90075, 114836, 93702, 131024, 19175, 124662, 20036, 34896, 33427, 60491, 103672, 107450),
      )),

      (96, 5, "Equihash is an asymmetric PoW based on the Generalised Birthday problem.".getBytes, BigInt(0), Seq.empty[Seq[Int]]),
      (96, 5, "Equihash is an asymmetric PoW based on the Generalised Birthday problem.".getBytes, BigInt(1), Seq(
        Seq(2154, 87055, 7922, 12920, 45189, 49783, 122795, 124296, 2432, 48178, 48280, 67880, 3912, 62307, 10987, 93891, 19673, 24483, 33984, 91500, 38171, 85505, 94625, 106140, 31530, 60861, 59391, 117337, 68078, 129665, 126764, 128278),
        Seq(3521, 83631, 86264, 106366, 62729, 102245, 74046, 114174, 45281, 59655, 45686, 60328, 71798, 123267, 83891, 121660, 12375, 83210, 94890, 120434, 35140, 109028, 65151, 89820, 18962, 24744, 55758, 116061, 63695, 125324, 98242, 125805),
      )),
      (96, 5, "Equihash is an asymmetric PoW based on the Generalised Birthday problem.".getBytes, BigInt(2), Seq(
        Seq(6310, 126030, 19266, 92728, 22993, 43617, 59500, 110969, 8633, 95173, 11769, 69347, 21455, 114538, 67360, 77234, 7538, 84336, 27001, 79803, 33408, 111870, 42328, 48938, 19045, 48081, 55314, 86688, 24992, 93296, 68568, 106618),
      )),
      (96, 5, "Equihash is an asymmetric PoW based on the Generalised Birthday problem.".getBytes, BigInt(10), Seq(
        Seq(6768, 10445, 80746, 128923, 28583, 50486, 47353, 58892, 35052, 45980, 61445, 103307, 67117, 94090, 78715, 109244, 20795, 102820, 31354, 91894, 50174, 126488, 77522, 80142, 28219, 74825, 66159, 73984, 60786, 121859, 70144, 120379),
        Seq(7865, 119271, 33055, 103984, 19519, 65954, 36562, 123493, 10038, 60327, 10645, 98001, 10748, 108967, 73961, 99283, 20538, 21631, 41159, 81213, 71041, 74642, 97906, 107612, 47736, 74711, 75451, 117319, 53428, 73882, 73362, 125084),
      )),
      (96, 5, "Equihash is an asymmetric PoW based on the Generalised Birthday problem.".getBytes, BigInt(11), Seq(
        Seq(637, 78032, 97478, 118268, 16058, 44395, 19029, 39150, 1566, 66582, 4084, 107252, 59619, 116281, 67957, 128728, 30916, 69051, 90422, 102716, 51905, 66753, 60509, 78066, 38568, 119630, 75839, 113134, 54356, 70996, 63085, 83048),
        Seq(4130, 71826, 46248, 50447, 4281, 129092, 23122, 103196, 9305, 34797, 111094, 127775, 82662, 120386, 109738, 124765, 24770, 125174, 83477, 102473, 45209, 79062, 84764, 125929, 31689, 95554, 66614, 127658, 31756, 55684, 53670, 53776),
      ))
    )

  val tasksAndSolutionValidationResult = Table(
    ("n", "k", "I", "nonce", "solution", "valid"),
    // Original valid solution
    (96, 5, "Equihash is an asymmetric PoW based on the Generalised Birthday problem.".getBytes, BigInt(1),
      Seq(2261, 15185, 36112, 104243, 23779, 118390, 118332, 130041, 32642, 69878, 76925, 80080, 45858, 116805, 92842, 111026, 15972, 115059, 85191, 90330, 68190, 122819, 81830, 91132, 23460, 49807, 52426, 80391, 69567, 114474, 104973, 122568),
      true),
    // Change one index
    (96, 5, "Equihash is an asymmetric PoW based on the Generalised Birthday problem.".getBytes, BigInt(1),
      Seq(2262, 15185, 36112, 104243, 23779, 118390, 118332, 130041, 32642, 69878, 76925, 80080, 45858, 116805, 92842, 111026, 15972, 115059, 85191, 90330, 68190, 122819, 81830, 91132, 23460, 49807, 52426, 80391, 69567, 114474, 104973, 122568),
      false),
    // Swap two arbitrary indices
    (96, 5, "Equihash is an asymmetric PoW based on the Generalised Birthday problem.".getBytes, BigInt(1),
      Seq(45858, 15185, 36112, 104243, 23779, 118390, 118332, 130041, 32642, 69878, 76925, 80080, 2261, 116805, 92842, 111026, 15972, 115059, 85191, 90330, 68190, 122819, 81830, 91132, 23460, 49807, 52426, 80391, 69567, 114474, 104973, 122568),
      false),
    // Reverse the first pair of indices
    (96, 5, "Equihash is an asymmetric PoW based on the Generalised Birthday problem.".getBytes, BigInt(1),
      Seq(15185, 2261, 36112, 104243, 23779, 118390, 118332, 130041, 32642, 69878, 76925, 80080, 45858, 116805, 92842, 111026, 15972, 115059, 85191, 90330, 68190, 122819, 81830, 91132, 23460, 49807, 52426, 80391, 69567, 114474, 104973, 122568),
      false),
    // Swap the first and second pairs of indices
    (96, 5, "Equihash is an asymmetric PoW based on the Generalised Birthday problem.".getBytes, BigInt(1),
      Seq(36112, 104243, 2261, 15185, 23779, 118390, 118332, 130041, 32642, 69878, 76925, 80080, 45858, 116805, 92842, 111026, 15972, 115059, 85191, 90330, 68190, 122819, 81830, 91132, 23460, 49807, 52426, 80391, 69567, 114474, 104973, 122568),
      false),
    // Swap the second-to-last and last pairs of indices
    (96, 5, "Equihash is an asymmetric PoW based on the Generalised Birthday problem.".getBytes, BigInt(1),
      Seq(2261, 15185, 36112, 104243, 23779, 118390, 118332, 130041, 32642, 69878, 76925, 80080, 45858, 116805, 92842, 111026, 15972, 115059, 85191, 90330, 68190, 122819, 81830, 91132, 23460, 49807, 52426, 80391, 104973, 122568, 69567, 114474),
      false),
    // Swap the first half and second half
    (96, 5, "Equihash is an asymmetric PoW based on the Generalised Birthday problem.".getBytes, BigInt(1),
      Seq(15972, 115059, 85191, 90330, 68190, 122819, 81830, 91132, 23460, 49807, 52426, 80391, 69567, 114474, 104973, 122568, 2261, 15185, 36112, 104243, 23779, 118390, 118332, 130041, 32642, 69878, 76925, 80080, 45858, 116805, 92842, 111026),
      false),
    // Sort the indices
    (96, 5, "Equihash is an asymmetric PoW based on the Generalised Birthday problem.".getBytes, BigInt(1),
      Seq(2261, 15185, 15972, 23460, 23779, 32642, 36112, 45858, 49807, 52426, 68190, 69567, 69878, 76925, 80080, 80391, 81830, 85191, 90330, 91132, 92842, 104243, 104973, 111026, 114474, 115059, 116805, 118332, 118390, 122568, 122819, 130041),
      false),
    // Duplicate indices
    (96, 5, "Equihash is an asymmetric PoW based on the Generalised Birthday problem.".getBytes, BigInt(1),
      Seq(2261, 2261, 15185, 15185, 36112, 36112, 104243, 104243, 23779, 23779, 118390, 118390, 118332, 118332, 130041, 130041, 32642, 32642, 69878, 69878, 76925, 76925, 80080, 80080, 45858, 45858, 116805, 116805, 92842, 92842, 111026, 111026),
      false),
    // Duplicate first half
    (96, 5, "Equihash is an asymmetric PoW based on the Generalised Birthday problem.".getBytes, BigInt(1),
      Seq(2261, 15185, 36112, 104243, 23779, 118390, 118332, 130041, 32642, 69878, 76925, 80080, 45858, 116805, 92842, 111026, 2261, 15185, 36112, 104243, 23779, 118390, 118332, 130041, 32642, 69878, 76925, 80080, 45858, 116805, 92842, 111026),
      false),
    (96, 5, "block header".getBytes, BigInt(1),
      Seq(1911, 96020, 94086, 96830, 7895, 51522, 56142, 62444, 15441, 100732, 48983, 64776, 27781, 85932, 101138, 114362, 4497, 14199, 36249, 41817, 23995, 93888, 35798, 96337, 5530, 82377, 66438, 85247, 39332, 78978, 83015, 123505), true),
    (96, 5, "Equihash is an asymmetric PoW based on the Generalised Birthday problem.".getBytes, BigInt(2),
      Seq(6005, 59843, 55560, 70361, 39140, 77856, 44238, 57702, 32125, 121969, 108032, 116542, 37925, 75404, 48671, 111682, 6937, 93582, 53272, 77545, 13715, 40867, 73187, 77853, 7348, 70313, 24935, 24978, 25967, 41062, 58694, 110036), true),
    (200, 9, "block header".getBytes, BigInt(0),
      Seq(4313, 223176, 448870, 1692641, 214911, 551567, 1696002, 1768726, 500589, 938660, 724628, 1319625, 632093, 1474613, 665376, 1222606, 244013, 528281, 1741992, 1779660, 313314, 996273, 435612, 1270863, 337273, 1385279, 1031587, 1147423, 349396, 734528, 902268, 1678799, 10902, 1231236, 1454381, 1873452, 120530, 2034017, 948243, 1160178, 198008, 1704079, 1087419, 1734550, 457535, 698704, 649903, 1029510, 75564, 1860165, 1057819, 1609847, 449808, 527480, 1106201, 1252890, 207200, 390061, 1557573, 1711408, 396772, 1026145, 652307, 1712346, 10680, 1027631, 232412, 974380, 457702, 1827006, 1316524, 1400456, 91745, 2032682, 192412, 710106, 556298, 1963798, 1329079, 1504143, 102455, 974420, 639216, 1647860, 223846, 529637, 425255, 680712, 154734, 541808, 443572, 798134, 322981, 1728849, 1306504, 1696726, 57884, 913814, 607595, 1882692, 236616, 1439683, 420968, 943170, 1014827, 1446980, 1468636, 1559477, 1203395, 1760681, 1439278, 1628494, 195166, 198686, 349906, 1208465, 917335, 1361918, 937682, 1885495, 494922, 1745948, 1320024, 1826734, 847745, 894084, 1484918, 1523367, 7981, 1450024, 861459, 1250305, 226676, 329669, 339783, 1935047, 369590, 1564617, 939034, 1908111, 1147449, 1315880, 1276715, 1428599, 168956, 1442649, 766023, 1171907, 273361, 1902110, 1169410, 1786006, 413021, 1465354, 707998, 1134076, 977854, 1604295, 1369720, 1486036, 330340, 1587177, 502224, 1313997, 400402, 1667228, 889478, 946451, 470672, 2019542, 1023489, 2067426, 658974, 876859, 794443, 1667524, 440815, 1099076, 897391, 1214133, 953386, 1932936, 1100512, 1362504, 874364, 975669, 1277680, 1412800, 1227580, 1857265, 1312477, 1514298, 12478, 219890, 534265, 1351062, 65060, 651682, 627900, 1331192, 123915, 865936, 1218072, 1732445, 429968, 1097946, 947293, 1323447, 157573, 1212459, 923792, 1943189, 488881, 1697044, 915443, 2095861, 333566, 732311, 336101, 1600549, 575434, 1978648, 1071114, 1473446, 50017, 54713, 367891, 2055483, 561571, 1714951, 715652, 1347279, 584549, 1642138, 1002587, 1125289, 1364767, 1382627, 1387373, 2054399, 97237, 1677265, 707752, 1265819, 121088, 1810711, 1755448, 1858538, 444653, 1130822, 514258, 1669752, 578843, 729315, 1164894, 1691366, 15609, 1917824, 173620, 587765, 122779, 2024998, 804857, 1619761, 110829, 1514369, 410197, 493788, 637666, 1765683, 782619, 1186388, 494761, 1536166, 1582152, 1868968, 825150, 1709404, 1273757, 1657222, 817285, 1955796, 1014018, 1961262, 873632, 1689675, 985486, 1008905, 130394, 897076, 419669, 535509, 980696, 1557389, 1244581, 1738170, 197814, 1879515, 297204, 1165124, 883018, 1677146, 1545438, 2017790, 345577, 1821269, 761785, 1014134, 746829, 751041, 930466, 1627114, 507500, 588000, 1216514, 1501422, 991142, 1378804, 1797181, 1976685, 60742, 780804, 383613, 645316, 770302, 952908, 1105447, 1878268, 504292, 1961414, 693833, 1198221, 906863, 1733938, 1315563, 2049718, 230826, 2064804, 1224594, 1434135, 897097, 1961763, 993758, 1733428, 306643, 1402222, 532661, 627295, 453009, 973231, 1746809, 1857154, 263652, 1683026, 1082106, 1840879, 768542, 1056514, 888164, 1529401, 327387, 1708909, 961310, 1453127, 375204, 878797, 1311831, 1969930, 451358, 1229838, 583937, 1537472, 467427, 1305086, 812115, 1065593, 532687, 1656280, 954202, 1318066, 1164182, 1963300, 1232462, 1722064, 17572, 923473, 1715089, 2079204, 761569, 1557392, 1133336, 1183431, 175157, 1560762, 418801, 927810, 734183, 825783, 1844176, 1951050, 317246, 336419, 711727, 1630506, 634967, 1595955, 683333, 1461390, 458765, 1834140, 1114189, 1761250, 459168, 1897513, 1403594, 1478683, 29456, 1420249, 877950, 1371156, 767300, 1848863, 1607180, 1819984, 96859, 1601334, 171532, 2068307, 980009, 2083421, 1329455, 2030243, 69434, 1965626, 804515, 1339113, 396271, 1252075, 619032, 2080090, 84140, 658024, 507836, 772757, 154310, 1580686, 706815, 1024831, 66704, 614858, 256342, 957013, 1488503, 1615769, 1515550, 1888497, 245610, 1333432, 302279, 776959, 263110, 1523487, 623933, 2013452, 68977, 122033, 680726, 1849411, 426308, 1292824, 460128, 1613657, 234271, 971899, 1320730, 1559313, 1312540, 1837403, 1690310, 2040071, 149918, 380012, 785058, 1675320, 267071, 1095925, 1149690, 1318422, 361557, 1376579, 1587551, 1715060, 1224593, 1581980, 1354420, 1850496, 151947, 748306, 1987121, 2070676, 273794, 981619, 683206, 1485056, 766481, 2047708, 930443, 2040726, 1136227, 1945705, 1722044, 1971986), true)
  )


  private val n = 96
  private val k = 5

  private def zcashPerson(n: Int, k: Int): Array[Byte] = "ZcashPoW".getBytes ++ leIntToByteArray(n) ++ leIntToByteArray(k)

  private def createDigest(n: Int, k: Int, I: Array[Byte], nonce: BigInt): Digest = {
    val digest = Blake2b.Digest.newInstance(new Blake2b.Param().setDigestLength(n / 8).setPersonal(zcashPerson(n, k)))
    digest.update(I)
    Equihash.hashNonce(digest, nonce)
  }

  property("zcashPerson") {
    zcashPerson(n, k) shouldBe Array(90, 99, 97, 115, 104, 80, 111, 87, 96, 0, 0, 0, 5, 0, 0, 0).map(_.toByte)
  }

  property("Blake2b person") {
    val digest = Blake2b.Digest.newInstance(new Blake2b.Param().setDigestLength(n / 8).setPersonal(zcashPerson(n, k)))
    digest.digest() shouldBe Array(20, 36, 1, 103, 212, 8, 139, 129, 145, 123, 113, 170).map(_.toByte)
  }

  property("createDigest") {
    createDigest(n, k, "block header".getBytes, BigInt(0)).digest() shouldBe Array(167, 27, 213, 250, 150, 156, 214, 215, 78, 59, 90, 67).map(_.toByte)
  }

  property("Equihash should solve gbp") {
    forAll(tasksAndSolutions) { (n: Int, k: Int, I: Array[Byte], nonce: BigInt, solutions: Seq[Seq[Int]]) =>
      val digest = createDigest(n, k, I, nonce)
      implicit val ord = new Ordering[Seq[Int]] {
        override def compare(x: Seq[Int], y: Seq[Int]): Int = {
          val (xx, yy) = x.zip(y).find { case (f, s) => f != s }.getOrElse((0, 0))
          xx - yy
        }
      }
      Equihash.gbpBasic(digest, n, k).sorted shouldBe solutions
    }
  }

  property("Equihash should validate solutions") {
    forAll(tasksAndSolutionValidationResult) { (n: Int, k: Int, I: Array[Byte], nonce: BigInt, solution: Seq[Int], valid: Boolean) =>
      val header = I ++ leIntToByteArray(nonce.toInt) ++ Array.fill(28)(0.toByte)
      Equihash.validateSolution(n, k, zcashPerson(n, k), header, solution) shouldBe valid
    }
  }
}
